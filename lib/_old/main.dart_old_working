import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:poc_builder/upload_controller.dart_old';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: const Text('Upload Control')),
        body: const Center(child: MyHomePage()),
      ),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key});

  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  late Map<String, void Function()> _retryCallback;

  final UploadController _uploadController = UploadController(
    onMaxAttemptsExceeded: (String message, void Function() retryCallback) {
      // _retryCallback = {message: retryCallback};
      print('onMaxAttemptsExceeded: $message');

      // handleRetry(message, retryCallback);
    },
  );

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        ElevatedButton(
          onPressed: () async {
            final result = await FilePicker.platform.pickFiles(
              withReadStream: true,
            );

            if (result == null) return;
            if (result.files.isEmpty) return;

            final file = result.files[0];

            if (file.readStream == null) return;

            await _uploadController.uploadStreamWithProgress(
              file.readStream!,
              file.name,
              file.size,
            );
          },
          child: const Text('Start Upload'),
        ),
        UploadControlWidget(uploadController: _uploadController),
      ],
    );
  }
}

class UploadControlWidget extends StatefulWidget {
  final UploadController uploadController;

  const UploadControlWidget({
    super.key,
    required this.uploadController,
  });

  @override
  _UploadControlWidgetState createState() => _UploadControlWidgetState();
}

class _UploadControlWidgetState extends State<UploadControlWidget> {
  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            IconButton(
              icon: const Icon(Icons.pause),
              onPressed: () => widget.uploadController.pause(),
            ),
            IconButton(
              icon: const Icon(Icons.play_arrow),
              onPressed: () => widget.uploadController.resume(),
            ),
            IconButton(
              icon: const Icon(Icons.cancel),
              onPressed: () => widget.uploadController.cancel(),
            ),
          ],
        ),
        ValueListenableBuilder(
          valueListenable: widget.uploadController.sendProgress,
          builder: (BuildContext context, double value, Widget? child) {
            return LinearProgressIndicator(
              value: value,
              minHeight: 5,
            );
          },
        ),
        ValueListenableBuilder(
          valueListenable: widget.uploadController.remainingTime,
          builder: (BuildContext context, String value, Widget? child) {
            return Text(
              'Remaining Time: $value',
            );
          },
        ),
      ],
    );
  }
}
/* Working prototype 
class UploadController extends ChangeNotifier {
  final Dio _dio = Dio();

  StreamSubscription<List<int>>? _chunkStreamSubscription;
  bool _isPaused = false;

  final ValueNotifier<double> sendProgress = ValueNotifier<double>(0);

  CancelToken? _cancelToken;

  void pause() {
    if (!_isPaused) {
      _isPaused = true;
      _chunkStreamSubscription?.pause();
    }
  }

  void resume() {
    if (_isPaused) {
      _isPaused = false;
      _chunkStreamSubscription?.resume();
    }
  }

  void cancel() {
    _cancelToken?.cancel();
    _chunkStreamSubscription?.cancel();
    sendProgress.value = 0;
  }

  Future<void> uploadStreamWithProgress(
    Stream<List<int>> readStream,
    String fileName,
    int fileSize,
  ) async {
    int chunkSize = 1024 * 1024; // 1MB
    int chunkIndex = 0;

    StreamController<List<int>> chunkStreamController = StreamController();
    _isPaused = false;

    _chunkStreamSubscription = readStream.listen((chunk) async {
      _chunkStreamSubscription?.pause();
      chunkStreamController.add(chunk);

      await _uploadChunk(chunk, fileName, fileSize, chunkIndex, chunkSize).then(
        (value) {
          _chunkStreamSubscription?.resume();
          chunkIndex++;
        },
      );

      _chunkStreamSubscription?.resume();
    }, onDone: () async {
      try {
        await finalizeUpload(fileName, chunkIndex);
        print('Upload completed');
      } catch (e) {
        print("Upload failed for chunk ${chunkIndex * chunkSize}: $e");
      } finally {
        chunkStreamController.close();
        print('Upload completed, closing stream');
      }
    });
  }

  Future<void> _uploadChunk(
    List<int> chunk,
    String fileName,
    int fileSize,
    int chunkIndex,
    int chunkSize,
  ) async {
    final mimeTye = lookupMimeType(fileName);
    final mediaType = mimeTye != null ? MediaType.parse(mimeTye) : null;
    FormData formData = FormData.fromMap({
      "chunk": MultipartFile.fromBytes(
        chunk,
        contentType: mediaType,
        filename: '$fileName-chunk-${chunkIndex * chunkSize}',
      ),
      "fileName": fileName,
      "chunkIndex": chunkIndex,
    });

    init a new cancel token on every request.
    _cancelToken = CancelToken();

    try {
      final response = await _dio.post(
        "http://localhost:3000/upload",
        data: formData,
        cancelToken: _cancelToken,
      );

      if (response.statusCode == 200) {
        sendProgress.value = (chunkIndex * chunkSize) / fileSize;
        chunkIndex++;
        print("Uploaded chunk ${(chunkIndex * chunkSize) / fileSize}");
      } else {
        print(
            "Upload failed for chunk ${chunkIndex * chunkSize}: ${response.statusCode}");
      }
    } catch (e) {
      print("Upload failed for chunk ${chunkIndex * chunkSize}: $e");
    }
  }

  Future<void> finalizeUpload(String fileName, int totalChunks) async {
    try {
      await _dio.post(
        'http://localhost:3000/finalize-upload',
        data: {
          'fileName': fileName,
          'totalChunks': totalChunks,
        },
      );
    } catch (e) {
      print(e);
    }
  }
}
*/

// class UploadController extends ChangeNotifier {
//   final Dio _dio = Dio();

//   StreamSubscription<List<int>>? _chunkStreamSubscription;
//   bool _isPaused = false;

//   final ValueNotifier<double> sendProgress = ValueNotifier<double>(0);
//   final ValueNotifier<String> remainingTime = ValueNotifier<String>('');

//   CancelToken? _cancelToken;

//   void pause() {
//     if (!_isPaused) {
//       _isPaused = true;
//       _chunkStreamSubscription?.pause();
//     }
//   }

//   void resume() {
//     if (_isPaused) {
//       _isPaused = false;
//       _chunkStreamSubscription?.resume();
//     }
//   }

//   void cancel() {
//     _cancelToken?.cancel();
//     _chunkStreamSubscription?.cancel();
//     sendProgress.value = 0;
//   }

//   // Add these variables to keep track of chunk upload times
//   int _totalChunksUploaded = 0;
//   int _totalTimeTaken = 0;

//   Future<void> uploadStreamWithProgress(
//     Stream<List<int>> readStream,
//     String fileName,
//     int fileSize,
//   ) async {
//     int chunkSize = 1024 * 1024; // 1MB
//     int chunkIndex = 0;

//     StreamController<List<int>> chunkStreamController = StreamController();
//     _isPaused = false;

//     _chunkStreamSubscription = readStream.listen((chunk) async {
//       _chunkStreamSubscription?.pause();
//       chunkStreamController.add(chunk);

//       DateTime startTime = DateTime.now(); // Add this line

//       await _uploadChunk(chunk, fileName, fileSize, chunkIndex, chunkSize).then(
//         (value) {
//           _chunkStreamSubscription?.resume();
//           chunkIndex++;

//           // Add these lines to update the remaining time
//           DateTime endTime = DateTime.now();
//           int chunkUploadTime = endTime.difference(startTime).inMilliseconds;
//           _totalChunksUploaded++;
//           _totalTimeTaken += chunkUploadTime;
//           int remainingChunks =
//               (fileSize / chunkSize).ceil() - _totalChunksUploaded;
//           int estimatedRemainingTime =
//               (_totalTimeTaken ~/ _totalChunksUploaded) * remainingChunks;
//           Duration remainingDuration =
//               Duration(milliseconds: estimatedRemainingTime);
//           remainingTime.value = _formatDuration(remainingDuration);
//         },
//       );

//       // _chunkStreamSubscription?.resume();
//     }, onDone: () async {
//       try {
//         await finalizeUpload(fileName, chunkIndex);
//         print('Upload completed');
//       } catch (e) {
//         print("Upload failed for chunk ${chunkIndex * chunkSize}: $e");
//       } finally {
//         chunkStreamController.close();
//         print('Upload completed, closing stream');
//       }
//     });
//   }

//   // Add this function to format the remaining time
//   String _formatDuration(Duration duration) {
//     String twoDigits(int n) => n.toString().padLeft(2, '0');
//     String twoDigitMinutes = twoDigits(duration.inMinutes.remainder(60));
//     String twoDigitSeconds = twoDigits(duration.inSeconds.remainder(60));
//     return "${twoDigits(duration.inHours)}:$twoDigitMinutes:$twoDigitSeconds";
//   }

//   Future<void> _uploadChunk(
//     List<int> chunk,
//     String fileName,
//     int fileSize,
//     int chunkIndex,
//     int chunkSize,
//   ) async {
//     final mimeTye = lookupMimeType(fileName);
//     final mediaType = mimeTye != null ? MediaType.parse(mimeTye) : null;
//     FormData formData = FormData.fromMap({
//       "chunk": MultipartFile.fromBytes(
//         chunk,
//         contentType: mediaType,
//         filename: '$fileName-chunk-${chunkIndex * chunkSize}',
//       ),
//       "fileName": fileName,
//       "chunkIndex": chunkIndex,
//     });

//     // init a new cancel token on every request.
//     _cancelToken = CancelToken();

//     try {
//       final response = await _dio.post(
//         "http://localhost:3000/upload",
//         data: formData,
//         cancelToken: _cancelToken,
//       );

//       if (response.statusCode == 200) {
//         sendProgress.value = (chunkIndex * chunkSize) / fileSize;
//         // chunkIndex++;
//         print("Uploaded chunk ${(chunkIndex * chunkSize) / fileSize}");
//       } else {
//         print(
//             "Upload failed for chunk ${chunkIndex * chunkSize}: ${response.statusCode}");
//       }
//     } catch (e) {
//       print("Upload failed for chunk ${chunkIndex * chunkSize}: $e");
//     }
//   }

//   Future<void> finalizeUpload(String fileName, int totalChunks) async {
//     try {
//       await _dio.post(
//         'http://localhost:3000/finalize-upload',
//         data: {
//           'fileName': fileName,
//           'totalChunks': totalChunks,
//         },
//       );
//     } catch (e) {
//       print(e);
//     }
//   }
// }
