import 'dart:async';

import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:http_parser/http_parser.dart';
import 'package:mime/mime.dart';

class UploadController extends ChangeNotifier {
  final Dio _dio = Dio();

  StreamSubscription<List<int>>? _chunkStreamSubscription;
  bool _isPaused = false;

  final ValueNotifier<double> sendProgress = ValueNotifier<double>(0);
  final ValueNotifier<String> remainingTime = ValueNotifier<String>('');

  CancelToken? _cancelToken;

  int _totalChunksUploaded = 0;
  int _totalTimeTaken = 0;

  static const int _maxAttempts = 3;

  final Function(String message, VoidCallback retryCallback)
      onMaxAttemptsExceeded;

  UploadController({required this.onMaxAttemptsExceeded});

  void pause() {
    if (!_isPaused) {
      _isPaused = true;
      _chunkStreamSubscription?.pause();
    }
  }

  void resume() {
    if (_isPaused) {
      _isPaused = false;
      _chunkStreamSubscription?.resume();
    }
  }

  void cancel() {
    _cancelToken?.cancel();
    _chunkStreamSubscription?.cancel();
    sendProgress.value = 0;
  }

  Future<void> uploadStreamWithProgress(
    Stream<List<int>> readStream,
    String fileName,
    int fileSize,
  ) async {
    int chunkSize = 1024 * 1024; // 1MB
    int chunkIndex = 0;

    StreamController<List<int>> chunkStreamController = StreamController();
    _isPaused = false;

    _chunkStreamSubscription = readStream.listen((chunk) async {
      _chunkStreamSubscription?.pause();
      chunkStreamController.add(chunk);

      DateTime startTime = DateTime.now();

      await _uploadChunk(chunk, fileName, fileSize, chunkIndex, chunkSize).then(
        (value) {
          _chunkStreamSubscription?.resume();
          chunkIndex++;

          DateTime endTime = DateTime.now();
          int chunkUploadTime = endTime.difference(startTime).inMilliseconds;
          _totalChunksUploaded++;
          _totalTimeTaken += chunkUploadTime;
          int remainingChunks =
              (fileSize / chunkSize).ceil() - _totalChunksUploaded;
          int estimatedRemainingTime =
              (_totalTimeTaken ~/ _totalChunksUploaded) * remainingChunks;
          Duration remainingDuration =
              Duration(milliseconds: estimatedRemainingTime);
          remainingTime.value = _formatDuration(remainingDuration);
        },
      );
    }, onDone: () async {
      try {
        await finalizeUpload(fileName, chunkIndex);
        print('Upload completed');
      } catch (e) {
        print("Upload failed for chunk ${chunkIndex * chunkSize}: $e");
      } finally {
        chunkStreamController.close();
        print('Upload completed, closing stream');
      }
    });
  }

  String _formatDuration(Duration duration) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    String twoDigitMinutes = twoDigits(duration.inMinutes.remainder(60));
    String twoDigitSeconds = twoDigits(duration.inSeconds.remainder(60));
    return "${twoDigits(duration.inHours)}:$twoDigitMinutes:$twoDigitSeconds";
  }

  Future<void> _uploadChunk(
    List<int> chunk,
    String fileName,
    int fileSize,
    int chunkIndex,
    int chunkSize,
  ) async {
    final mimeTye = lookupMimeType(fileName);
    final mediaType = mimeTye != null ? MediaType.parse(mimeTye) : null;
    FormData formData = FormData.fromMap({
      "chunk": MultipartFile.fromBytes(
        chunk,
        contentType: mediaType,
        filename: '$fileName-chunk-${chunkIndex * chunkSize}',
      ),
      "fileName": fileName,
      "chunkIndex": chunkIndex,
    });

    _cancelToken = CancelToken();

    int attempt = 0;
    bool success = false;
    while (attempt < _maxAttempts && !success) {
      try {
        final response = await _dio.post(
          "http://localhost:3000/upload",
          data: formData,
          cancelToken: _cancelToken,
        );

        if (response.statusCode == 200) {
          sendProgress.value = (chunkIndex * chunkSize) / fileSize;
          print("Uploaded chunk ${((chunkIndex + 1) * chunkSize) / fileSize}");
        } else {
          print(
              "Upload failed for chunk ${(chunkIndex + 1) * chunkSize}: ${response.statusCode}");
        }

        success = true;
      } catch (e) {
        attempt++;
        print(
            "Attempt $attempt failed for chunk ${chunkIndex * chunkSize}: $e");

        if (attempt == _maxAttempts) {
          // Wait for connectivity before asking the user
          await _waitForConnectivity();

          // Use Completer to wait for user action
          Completer<void> userActionCompleter = Completer<void>();

          onMaxAttemptsExceeded(
            "Maximum attempts exceeded for chunk ${(chunkIndex + 1) * chunkSize}. Retry?",
            () {
              // If the user chooses to retry, reset the attempt counter and continue the loop
              attempt = 0;
              userActionCompleter.complete();
            },
          );

          // Wait for the user to take action
          await userActionCompleter.future;
        } else {
          // Wait for connectivity before retrying
          try {
            await _waitForConnectivity();
          } catch (e) {
            print(e);
          }
        }
      }
    }
  }

  // Add this method to wait for connectivity
  Future<void> _waitForConnectivity() async {
    ConnectivityResult connectivityResult =
        await Connectivity().checkConnectivity();
    if (connectivityResult == ConnectivityResult.none) {
      await for (connectivityResult in Connectivity().onConnectivityChanged) {
        if (connectivityResult != ConnectivityResult.none) {
          break;
        }
      }
    }
  }

  Future<void> finalizeUpload(String fileName, int totalChunks) async {
    try {
      await _dio.post(
        'http://localhost:3000/finalize-upload',
        data: {
          'fileName': fileName,
          'totalChunks': totalChunks,
        },
      );
    } catch (e) {
      print(e);
    }
  }
}
